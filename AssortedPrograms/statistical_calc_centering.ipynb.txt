{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# This runs some statistical calculations as a cheatsheet for students\n",
    "\n",
    "### Using Numpy arrays\n",
    "* In Python when one hears arrays it typically is referring to numpy\n",
    "  * The other thing it can refer to are array (`array.array`) types which are thin wrappers over C arrays\n",
    "* Lists, Sets, and Tuples are the typical \"pure python\" implementations of position based data collections\n",
    "\n",
    "## Example\n",
    "  The example will use the idea of figuring statistics on a persons scores in a class - as this is a pretty standard and understandable example."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 63  81  73  63  89  90  80  90  64  81  64  65  91  79  70  96  76  64\n",
      "  89  96  88  82  68  92  67  88  81  75  80  61  66  92  63  81  85  89\n",
      "  85  87  71  90  61 100  84  96  75  95  95 100  62  82]\n",
      "<class 'numpy.ndarray'>\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "### Start by creating a 50 element numpy array for calculations\n",
    "# np.random.random(50) if floats wanted or np.random.random((50,3)) if a 50 x 3 matrix wanted\n",
    "# We'll assume the person was passing and use a 60-100 spread over 50 and then 51 elements (to show median)\n",
    "\n",
    "scores = np.random.random_integers(60,100, 51)\n",
    "print(scores)\n",
    "print(type(scores)) # This will show this is not a List but an ndarray"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Your average grade was 80.1, highest score was 100, lowest was 61\n"
     ]
    }
   ],
   "source": [
    "### Now a few simple calculations: mean, highest score, and lowest score\n",
    "# We'll need these values again so instead of having to recalculate them all the time we can use a dict to store\n",
    "s_attribs = {\"mean\": np.mean(scores), \"max\": np.max(scores), \"min\": np.min(scores)}\n",
    "\n",
    "print(\"Your average grade was {}, highest score was {}, lowest was {}\".format(s_attribs['mean'], s_attribs['max'], s_attribs['min']))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The median was 81\n",
      "The median was 81.0\n"
     ]
    }
   ],
   "source": [
    "### Now to find the median value - first the normal way then the numpy way\n",
    "# Note one can use np.shape to find the shape of the array which will be a tuple of the (rows, columns) or len()\n",
    "# This will use shape just to show that method as len() is used in many other examples\n",
    "\n",
    "elements = scores.shape[0]\n",
    "scores.sort() #This will sort the array in-place - use sorted() if you do not want to keep array sorted\n",
    "\n",
    "if elements % 2:\n",
    "    # The half way point is not exact\n",
    "    print(\"The median was {}\".format((scores[(elements // 2) - 1] + scores[elements // 2]) / 2))\n",
    "else:\n",
    "    # The half way point is exact use that\n",
    "    print(\"The median was {}\".format(scores[elements // 2]))\n",
    "    \n",
    "#or we could just do this without even needing to sort\n",
    "# and add this to the dictionary\n",
    "s_attribs[\"median\"] = np.median(scores)\n",
    "print(\"The median was {}\".format(s_attribs[\"median\"]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from collections import Counter # for the next section"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Counter({81: 4, 64: 3, 89: 3, 90: 3, 96: 3, 63: 3, 75: 2, 80: 2, 82: 2, 85: 2, 88: 2, 92: 2, 95: 2, 100: 2, 61: 2, 65: 1, 66: 1, 67: 1, 68: 1, 70: 1, 71: 1, 73: 1, 76: 1, 79: 1, 84: 1, 87: 1, 91: 1, 62: 1})\n",
      "The mode is 81\n"
     ]
    }
   ],
   "source": [
    "### Now to get some counts\n",
    "# We'll be building a counter object so first lets try the quick way to find the mode (or most frequent value)\n",
    "\n",
    "## s_attribs[\"mode\"] = np.mode(scores) <- causes an Attribute error\n",
    "## print(\"Most frequent grade was {}\".format(s_attribs[\"mode\"]))\n",
    "\n",
    "### Well that didn't work, apparently numpy doesn't have a mode (scipy.stats does fyi)\n",
    "## Then again we'll need some frequecy counts for other reasons anyway so its time to learn to count\n",
    "\n",
    "score_count = Counter(scores)\n",
    "\n",
    "print(score_count)\n",
    "print(\"The mode is {}\".format(score_count.most_common(1)[0][0])) \n",
    "# change as we explain need to get call the first index twice and inherent problem with this method (ie same count)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ModeResult(mode=array([81]), count=array([4]))\n"
     ]
    }
   ],
   "source": [
    "### Okay just because it annoys me - I really just want the counts - a better way to get the mode is\n",
    "from scipy.stats import mode\n",
    "\n",
    "print(mode(scores)) #but we'll get to that in a later lesson"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "([<matplotlib.axis.XTick at 0x7f06f41092b0>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f4109c50>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f40fa5f8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3fe4908>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3fe8358>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3fe8d68>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3feb7b8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3fef208>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f40ce0b8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f4100208>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3fef668>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3ff4048>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3ff4a58>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3ff64a8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3ff6eb8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3ffa908>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3ffe358>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3ffed68>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f40027b8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f4008208>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f4008c18>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f400a668>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f400e0b8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f400eac8>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f4012518>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f4012f28>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f4016978>,\n",
       "  <matplotlib.axis.XTick at 0x7f06f3f9b3c8>],\n",
       " <a list of 28 Text xticklabel objects>)"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\nbYhfAADaEL8AALQhfgEAaEP8AgDQhvgFAKAN8QsAQBviFwCANsQvAABtiF8AANoQvwAAtCF+AQBo\nQ/wCANCG+AUAoA3xCwBAG+IXAIA2xC8AAG2IXwAA2jhQ/FbV86rq1qp6f1X90C7bvLKqbquqE1V1\n3upL21p9xIM+e9PmrnP2ps1d5+xNm7vO2Zs2d52zzV3/7E2bu87ZmzZ3nbM3be46Z69r7qlt3/it\nqiNJfi7Jc5N8eZJvr6q/v2ObC5M8ZYxxdpLLkly5+tK2Vh/xoM/etLnrnL1pc9c5e9PmrnP2ps1d\n52xz1z970+auc/amzV3n7E2bu87Z65p7ajvIT36fmeS2McaHxxifSfK6JBfv2ObiJFcnyRjjuiSn\nV9WxSVcKAAArOkj8npHk9m0ff3R+217b3LFgGwAAeEjVGGPvDaq+LclzxxjfM//4nyV55hjjpdu2\n+c0k/2GM8Yfzj9+W5AfHGDfsmLX3JwMAgImMMWrnbUcP8OfuSHLmto+fOL9t5zZfus82CxcAAAAP\nloNc9vDuJE+tqrOq6lFJXpTk2h3bXJvkkiSpqvOT3D3GuGvSlQIAwIr2/cnvGONzVfWSJG/NLJZf\nNca4paoum909rhpjvLmqnl9VH0jyySSXrnfZAABwePte8wsAAA8Xp8y/8FZVp1fVr1XVLVX13qr6\nmm33/euqureqvmCKuVV1eVV9tKpumL89b6r1VtX3zm+7qap+/LBz91jz66rqxvl6P1RVN+w/6UBz\nv7Kq/mg++11V9VWHnHnOtnXdWFWfqKqXVtXnV9Vbq+p9VfU7VXX6EuvdbfYLqurPqupzVfX0Cef+\nWFX96fy2366qJ0w0d4rjbeHs+X1LH3N7rPkrquoP5/vjjVX1uCXW/H3zx+k9VfUrVfWoiY6LnXNP\nW/WY2Gf2T87374mq+vWqevwEcx+17b5Vzm+L1rvy8bbH7Ndtm7vseWjRcbHSeWifuSsdx/PZL5t/\nfd207etuimN50dyVj+Vd5q58HO8xe4pz3Pa5L9t2+6HPb1X1qqq6q6res+22XR+vqvqRmv0jXbdU\n1TcfYs2LnlOnePwWzZ3iPLRo7krPextrjHFKvCX55SSXzt8/muTx8/efmOS3k3woyRdMMPf0JJcn\n+f6p15vkeGaXhxyd3/5FU+6Lbff/VJJXTLQvfifJN89vuzDJO1bYJ0eSfCyzX378icz+xo8k+aEk\n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\nJdnISU0AAAAASUVORK5CYII=\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f06f41949b0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "### Well we have a numbers and frequencies so maybe we should do a quick histogram\n",
    "\n",
    "# First create lists of our labels and indexes\n",
    "lbls, counts = zip(*score_count.items())\n",
    "idx = np.arange(len(lbls))\n",
    "\n",
    "### This will take a bit of explaining: using splat command in Python 3 to `expand` the values returned by a method\n",
    "##  And the need to get the length of labels (or score_count) as this will provide the indexes (indices?)\n",
    "\n",
    "plt.figure(figsize=(12,12)) # Chane the graph size (play with this as you want)\n",
    "plt.bar(idx, counts, 1) # 1 = width\n",
    "plt.xticks(idx + 0.5, lbls) # Think labels (hence why we called it labels) - if width changes do width * .5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
