{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Example of performing Vector mathmatical function using Python List structures\n",
    "\n",
    "***\n",
    "\n",
    "Vector methods to be created:\n",
    "* Sum vectors\n",
    "  * Add vector elements of same sized vectors\n",
    "  * Return resulting vector\n",
    "* Subtract vectors\n",
    "  * Subtract vector elements of same sized vectors\n",
    "  * Return resulting vector\n",
    "* Product of vectors\n",
    "  * Product of components of vectors\n",
    "  * Return resulting vector\n",
    "* Product of vector and scalar\n",
    "  * Return scalar product of each element of vector\n",
    "* Mean of vectors\n",
    "  * Sum Vector method / number of elements for each element (or 1/len scalar multiply)\n",
    "* Dot Product\n",
    "  * Sum of component wise products\n",
    "  * Multiply vectors\n",
    "  * Sum vectors\n",
    "  * Return resulting vector\n",
    "\n",
    "***\n",
    "### Teaching notes *delete when finished*\n",
    "#### Remember to explain that in the real world numpy and other libraries would be used to do this\n",
    "* For teaching list methods\n",
    "  * Particuliarly allows for a number of list comprehensions to be explained\n",
    "* Basic Class definition and issues\n",
    "  * Start with just calling a definition directly (which will Error with a not found)\n",
    "  * Show how adding self.function_name() works and explain\n",
    "  * Move into using decorators\n",
    "* Start with a vector with a small number of elements\n",
    "  * So students can do calculations in their heads and follow along"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Sum of vectors = [4, 6, 5]\n",
      "Subtraction of vectors = [-2, -2, -1]\n",
      "Product of vectors = [3, 8, 6]\n",
      "Product of Sum of vectors and 2 = [8, 12, 10]\n",
      "\n",
      "Average of vectors = ['1.33', '2.00', '1.67']\n",
      "The Dot Product is 17\n"
     ]
    }
   ],
   "source": [
    "class vector_math:\n",
    "    '''\n",
    "    This is the base class for vector math - which allows for initialization with two vectors.\n",
    "    '''\n",
    "    \n",
    "    def __init__(self, vectors = [[1,2,2],[3,4,3]]):\n",
    "        self.vect1 = vectors[0]\n",
    "        self.vect2 = vectors[1]\n",
    "        \n",
    "    def set_vects(self, vectors):\n",
    "        self.vect1 = vectors[0]\n",
    "        self.vect2 = vectors[1]\n",
    "    \n",
    "    def sum_vects(self):\n",
    "        return [x + y for x, y in zip(self.vect1, self.vect2)]\n",
    "    \n",
    "    def sub_vects(self):\n",
    "        # default should be [-2,-2,-1]\n",
    "        return [x - y for x, y in zip(self.vect1, self.vect2)]\n",
    "        # Can expand out to for x, y in zip: ... to show what it and sum do\n",
    "    \n",
    "    def multi_vects(self):\n",
    "        #default should be [3,8,6]\n",
    "        return [x * y for x, y in zip(self.vect1, self.vect2)]\n",
    "    \n",
    "    def multi_scalar(self, scalar, vect):\n",
    "        return [e * scalar for e in vect]\n",
    "        # Show difference between just element * number and using tuple from zip()\n",
    "        \n",
    "    def multi_scalar_l(self, scalar, vect):\n",
    "        return lambda e: e * scalar, vect\n",
    "        \n",
    "    def mean_vects(self):\n",
    "        mean_vect = self.sum_vects()\n",
    "        return self.multi_scalar(1/len(mean_vect), mean_vect)\n",
    "        \n",
    "    def dot_product(self):\n",
    "        return sum(self.multi_vects())\n",
    "    \n",
    "vect = vector_math()\n",
    "\n",
    "sum_vect = vect.sum_vects()\n",
    "print(\"Sum of vectors = {}\".format(sum_vect))\n",
    "\n",
    "print(\"Subtraction of vectors = {}\".format(vect.sub_vects()))\n",
    "print(\"Product of vectors = {}\".format(vect.multi_vects()))\n",
    "print(\"Product of Sum of vectors and 2 = {}\\n\".format(vect.multi_scalar(2, sum_vect)))\n",
    "# Yep can still use character returns and others in format\n",
    "\n",
    "print(\"Average of vectors = {}\".format([\"{:.2f}\".format(e) for e in vect.mean_vects()]))\n",
    "# Now there are other ways to reduce the decimal places but this was just to show a nested format call\n",
    "\n",
    "# TODO: Consider adding timeit to show difference between calling multi_scalar directly and calling mean_vect:\n",
    "#print(\"Average of vectors through calling scalar = {}\".format(\n",
    "#        [\"{:.2f}\".format(e) for e in vect.multi_scalar(1/len(sum_vect), sum_vect)]))\n",
    "\n",
    "print(\"The Dot Product is {}\".format(vect.dot_product()))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "#### Other vector operations that could be done"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Sum of Squares is 9\n",
      "Magnitude is 3.00\n",
      "Distance is 3.0\n"
     ]
    }
   ],
   "source": [
    "from math import sqrt\n",
    "\n",
    "# Using the vect variables showing without functions\n",
    "sum_of_squares = sum([x * y for x, y in zip(vect.vect1, vect.vect1)])\n",
    "magnitude = sqrt(sum_of_squares)\n",
    "distance = sqrt(sum([(x - y) ** 2 for x, y in zip(vect.vect1, vect.vect2)]))\n",
    "\n",
    "print(\"Sum of Squares is {}\".format(sum_of_squares))\n",
    "print(\"Magnitude is {:.2f}\".format(magnitude))\n",
    "print(\"Distance is {}\".format(distance))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## List Comprehensions are Powerful tools in Python\n",
    "***Expect to see them throughout code one has to maintain but also understand they are not always the optimal solution***\n",
    "\n",
    "When an iteration is needed to build a composite value, list comprehensions are considered the most readable or understandable way to achieve this. Loops may be used instead if one wants the \"side effect\" of an interation while functional tools may be used if optimization and code speed is important.\n",
    "\n",
    "For instance, the above examples could also have been performed with an annoymous lambda or reduce, like:\n",
    "\n",
    "    def multi_scalar(self, vect, scalar):\n",
    "        return lambda e: e * scalar, vect\n",
    "\n",
    "In this case, the lambda would be faster by a minimal amount and actually have one less function call - which are expensive in Python. This is not always true as the need for an increasing amount of functional methods can change both the speed and amount of function call required. *code example is below*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "list comp\n",
      "  1           0 LOAD_CONST               0 (<code object <listcomp> at 0x7fb1987a35d0, file \"<stdin>\", line 1>)\n",
      "              3 LOAD_CONST               1 ('<listcomp>')\n",
      "              6 MAKE_FUNCTION            0\n",
      "              9 LOAD_NAME                0 (vect)\n",
      "             12 GET_ITER\n",
      "             13 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n",
      "             16 POP_TOP\n",
      "             17 LOAD_CONST               2 (None)\n",
      "             20 RETURN_VALUE\n",
      "0.00032782554626464844\n",
      "\n",
      "\n",
      "\n",
      "lambda\n",
      "  1           0 LOAD_CONST               0 (<code object <lambda> at 0x7fb19872c1e0, file \"<stdin>\", line 1>)\n",
      "              3 LOAD_CONST               1 ('<lambda>')\n",
      "              6 MAKE_FUNCTION            0\n",
      "              9 LOAD_NAME                0 (vect)\n",
      "             12 BUILD_TUPLE              2\n",
      "             15 POP_TOP\n",
      "             16 LOAD_CONST               2 (None)\n",
      "             19 RETURN_VALUE\n",
      "0.00039315223693847656\n"
     ]
    }
   ],
   "source": [
    "import dis\n",
    "import time\n",
    "\n",
    "# For instruction - shows disassemble of methods and performs quick time check\n",
    "\n",
    "vect = [2,3,3,3,4,5,6,6,4,3,2,1,3,4,5,6,4,3,2,1,3,4,5,6,4,3,2]\n",
    "\n",
    "t1 = time.time()\n",
    "\n",
    "print(\"list comp\")\n",
    "dis.dis(compile(\"[e * 2 for e in vect]\", '<stdin>', 'exec'))\n",
    "\n",
    "d_l = time.time() - t1\n",
    "print(d_l)\n",
    "\n",
    "t2 = time.time()\n",
    "\n",
    "print(\"\\n\\n\\nlambda\")\n",
    "dis.dis(compile(\"lambda e: e * 2, vect\", '<stdin>', 'exec'))\n",
    "\n",
    "d_lam = time.time() - t2\n",
    "print(d_lam)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
